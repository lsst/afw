# This file is part of afw.
#
# Developed for the LSST Data Management System.
# This product includes software developed by the LSST Project
# (https://www.lsst.org).
# See the COPYRIGHT file at the top-level directory of this distribution
# for details of code ownership.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


class DisplayImpl:
    """Back-end for display objects.

    Parameters
    ----------
    display
        The display object that we're providing the implementation for
    verbose : `bool`
        be chatty?
    """
    def __init__(self, display, verbose=False):
        self.display = display
        self.verbose = verbose

    def __del__(self):
        self._close()

    def _close(self):
        """Close the display, cleaning up any allocated resources
        """
        if hasattr(self, "verbose") and self.verbose and hasattr(self, "display"):
            print("virtual[%s]._close()" % (self.frame))

    def _buffer(self, enable=True):
        """Enable or disable buffering of writes to the display

        Parameters
        ----------
        enable : `bool`
            `True` or `False`, as appropriate
        """
        if self.verbose:
            print("virtual[%s]._buffer(%s)" % (self.frame, enable))

    def _dot(self, symb, c, r, size, ctype, *args, **kwargs):
        """Draw a symbol at (c, r)

        Parameters
        ----------
        symb
            The desired symbol. See `dot` for details
        c : `float`
            (x) column position
        r : `float`
            (y) row position
        size : `int`
            Size of symbol, in pixels
        ctype : `str`
            The desired color, either e.g. `lsst.afw.display.RED` or a color name known to X11
        *args
            Extra arguments to backend
        **kwargs
            Extra keyword arguments to backend
        """
        if self.verbose:
            print("virtual[%s]._dot('%s', %.2f, %.2f, size=%g, ctype=%s, %s, %s)" %
                  (self.frame, symb, c, r, size, ctype, args, kwargs))

    def _drawLines(self, points, ctype):
        """Draw line defined by the list points

        Parameters
        ----------
        points : `list` of `tuple` of `float`
            A list of 0-indexed positions [(x, y), (x, y), ...]
        ctype : `str`
            The desired color, either e.g. `lsst.afw.display.RED` or a color name known to X11
        """
        if self.verbose:
            print("virtual[%s]._drawLines(%s, ctype=%s)" %
                  (self.frame, points, ctype))

    def _erase(self):
        """Erase all glyphs drawn on display
        """
        if self.verbose:
            print("virtual[%s]._erase()" % (self.frame))

    def _flush(self):
        """Flush any I/O buffers
        """
        if self.verbose:
            print("virtual[%s]._flush()" % self.frame)

    def _setCallback(self, what, func):
        if self.verbose > 1:
            print("setCallback %s -> %s" % (what, func))

    def _getEvent(self):
        """Return an event generated by a keypress or mouse click
        """
        from .interface import Event
        ev = Event("q")

        if self.verbose:
            print("virtual[%s]._getEvent() -> %s" % (self.frame, ev))

        return ev

    def _getMaskTransparency(self):
        """Return the mask transparency for a display
        """
        if self.verbose:
            print("virtual[%s]._getMaskTransparency()" % self.frame)

    def _mtv(self, image, wcs=None, mask=None, title="", metadata=None):
        """Display an image and maybe a mask overlay on a display

        Parameters
        ----------
        image : `lsst.afw.image.Image`
            `~lsst.afw.image.Image` to display
        mask : `lsst.afw.image.Mask`
            `~lsst.afw.image.Mask` to display
        wcs : `lsst.afw.geom.SkyWcs`
            A Wcs to associate with data
        title : `str`
            Name to display with the data
        metadata : `lsst.daf.base.PropertySet`
            Additional metadata.
        """
        if self.verbose:
            print("virtual[%s]._mtv(image=%s, mask=%s, wcs=%s, title=\"%s\", metadata=\"%s\")" %
                  (self.frame, "Image" if image else None,
                   "Mask" if mask else None, "Wcs" if wcs else None, title,
                   f"{len(metadata)} cards" if metadata else "None"))

    def _setImageColormap(self, cmap):
        """Set the desired colormap

        Parameters
        ----------
        cmap : `str`
            the name of a colormap (e.g. "gray") or a backend-specific object
        """
        if self.verbose:
            print("virtual[%s]._setImageColormap(cmap=\"%s\")" % (self.frame, cmap))

    def _setMaskTransparency(self, transparency, maskplane):
        """Set the transparency of a maskplane

        Parameters
        ----------
        transparency : `float`
            The desired transparency, in the range [0, 100]
        maskplane
            The maskplane to set (None: all)
        """
        if self.verbose:
            print("virtual[%s]._setMaskTransparency(%g, maskplane=\"%s\")" %
                  (self.frame, transparency, maskplane))

    def _scale(self, algorithm, min, max, *args, unit=None, **kwargs):
        """Set the scaling from DN to displayed pixels

        Parameters
        ----------
        algorithm
            Scaling algorithm (e.g. linear)
        min
            The minimum value of the stretch (or "zscale" or "minmax")
        max
            The maximum value of the stretch
        unit
            Units for min and max (e.g. Percent, Absolute, Sigma)
        *args
            Optional arguments to the backend
        **kwargs
            Optional keyword arguments to the backend
        """
        if self.verbose:
            print("virtual[%s]._scale(%s, %s, %s, %s, %s, %s)" % (self.frame, algorithm,
                                                                  min, max, unit, args, kwargs))

    def _show(self):
        """Show the requested display
        """
        if self.verbose:
            print("virtual[%s]._show()" % self.frame)

    def _pan(self, r, c):
        """Pan to a row and column

        Parameters
        ----------
        c : `float`
            Desired column (x) position
        r : `float`
            Desired row (y) position
        """
        if self.verbose:
            print("virtual[%s]._pan(%.2f, %.2f)" % (self.frame, r, c))

    def _zoom(self, zoomfac):
        """Set the zoom

        Parameters
        ----------
        zoomfac : `float`
            Zoom factor to use
        """
        if self.verbose:
            print("virtual[%s]._zoom(%g)" % (self.frame, zoomfac))
